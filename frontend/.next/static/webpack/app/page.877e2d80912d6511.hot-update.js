"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCamera.ts":
/*!****************************!*\
  !*** ./hooks/useCamera.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCamera: () => (/* binding */ useCamera)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/api */ \"(app-pages-browser)/./services/api.ts\");\n\n\nfunction useCamera(cameraId) {\n    const [stream, setStream] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const reconnectTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    const reconnectAttemptsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const MAX_RECONNECT_ATTEMPTS = 5;\n    const RECONNECT_INTERVAL = 3000;\n    const connectToCamera = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCamera.useCallback[connectToCamera]\": async ()=>{\n            try {\n                setLoading(true);\n                setError(null);\n                // 關閉現有連接\n                if (wsRef.current) {\n                    wsRef.current.close();\n                }\n                // 創建新的WebSocket連接\n                const wsUrl = (0,_services_api__WEBPACK_IMPORTED_MODULE_1__.getWebSocketUrl)(cameraId);\n                console.log('正在連接到WebSocket服務器:', wsUrl);\n                const ws = new WebSocket(wsUrl);\n                wsRef.current = ws;\n                ws.onopen = ({\n                    \"useCamera.useCallback[connectToCamera]\": ()=>{\n                        console.log('WebSocket連接已建立');\n                        setIsConnected(true);\n                        setLoading(false);\n                        setError(null);\n                        reconnectAttemptsRef.current = 0;\n                    }\n                })[\"useCamera.useCallback[connectToCamera]\"];\n                ws.onmessage = ({\n                    \"useCamera.useCallback[connectToCamera]\": (event)=>{\n                        try {\n                            const data = JSON.parse(event.data);\n                            if (data.type === 'frame') {\n                                setStream({\n                                    imageUrl: \"data:image/jpeg;base64,\".concat(data.image),\n                                    timestamp: new Date(data.timestamp).getTime(),\n                                    metadata: {\n                                        cameraName: data.camera_name,\n                                        frameNumber: data.frame_number\n                                    }\n                                });\n                                setLoading(false);\n                            } else if (data.type === 'error') {\n                                console.error('收到錯誤消息:', data.message);\n                                setError(new Error(data.message));\n                                setLoading(false);\n                            }\n                        } catch (err) {\n                            console.error('解析攝影機數據失敗:', err);\n                            setError(new Error('解析攝影機數據失敗'));\n                        }\n                    }\n                })[\"useCamera.useCallback[connectToCamera]\"];\n                ws.onerror = ({\n                    \"useCamera.useCallback[connectToCamera]\": (event)=>{\n                        const errorTime = new Date().toISOString();\n                        const readyStateText = ws.readyState === 0 ? '正在連接' : ws.readyState === 1 ? '已連接' : ws.readyState === 2 ? '正在關閉' : ws.readyState === 3 ? '已關閉' : '未知狀態';\n                        const errorMessage = event.error instanceof Error ? \"\".concat(event.error.name, \": \").concat(event.error.message) : typeof event.message === 'string' ? event.message : '未知錯誤';\n                        // 簡化錯誤日誌\n                        console.error(\"WebSocket 連接錯誤 - \".concat(errorTime, \" - \").concat(errorMessage, \" - \").concat(wsUrl, \" - \").concat(readyStateText));\n                        // 更新狀態\n                        setError(new Error(\"攝影機連接錯誤: \".concat(errorMessage)));\n                        setIsConnected(false);\n                        setLoading(false);\n                    }\n                })[\"useCamera.useCallback[connectToCamera]\"];\n                ws.onclose = ({\n                    \"useCamera.useCallback[connectToCamera]\": (event)=>{\n                        console.log('WebSocket連接已關閉:', {\n                            code: event.code,\n                            reason: event.reason || '無原因提供',\n                            wasClean: event.wasClean,\n                            timestamp: new Date().toISOString()\n                        });\n                        setIsConnected(false);\n                        // 嘗試重連\n                        if (reconnectAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\n                            reconnectTimeoutRef.current = setTimeout({\n                                \"useCamera.useCallback[connectToCamera]\": ()=>{\n                                    console.log(\"嘗試重新連接 (\".concat(reconnectAttemptsRef.current + 1, \"/\").concat(MAX_RECONNECT_ATTEMPTS, \")\"));\n                                    reconnectAttemptsRef.current += 1;\n                                    connectToCamera();\n                                }\n                            }[\"useCamera.useCallback[connectToCamera]\"], RECONNECT_INTERVAL);\n                        } else {\n                            setError(new Error(\"無法連接到攝影機，已嘗試 \".concat(MAX_RECONNECT_ATTEMPTS, \" 次\")));\n                        }\n                    }\n                })[\"useCamera.useCallback[connectToCamera]\"];\n            } catch (err) {\n                console.error('連接錯誤:', err);\n                setError(err instanceof Error ? err : new Error('連接攝影機時發生錯誤'));\n                setLoading(false);\n            }\n        }\n    }[\"useCamera.useCallback[connectToCamera]\"], [\n        cameraId\n    ]);\n    // 手動重連函數\n    const reconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCamera.useCallback[reconnect]\": ()=>{\n            reconnectAttemptsRef.current = 0;\n            connectToCamera();\n        }\n    }[\"useCamera.useCallback[reconnect]\"], [\n        connectToCamera\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCamera.useEffect\": ()=>{\n            connectToCamera();\n            // 清理函數\n            return ({\n                \"useCamera.useEffect\": ()=>{\n                    if (reconnectTimeoutRef.current) {\n                        clearTimeout(reconnectTimeoutRef.current);\n                    }\n                    if (wsRef.current) {\n                        wsRef.current.close();\n                    }\n                }\n            })[\"useCamera.useEffect\"];\n        }\n    }[\"useCamera.useEffect\"], [\n        connectToCamera\n    ]);\n    return {\n        stream,\n        loading,\n        error,\n        isConnected,\n        reconnect\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBLE9BQU87WUFDUDt1Q0FBTztvQkFDTCxJQUFJTCxvQkFBb0JNLE9BQU8sRUFBRTt3QkFDL0J3QyxhQUFhOUMsb0JBQW9CTSxPQUFPO29CQUMxQztvQkFDQSxJQUFJUCxNQUFNTyxPQUFPLEVBQUU7d0JBQ2pCUCxNQUFNTyxPQUFPLENBQUNDLEtBQUs7b0JBQ3JCO2dCQUNGOztRQUNGOzhCQUFHO1FBQUNGO0tBQWdCO0lBRXBCLE9BQU87UUFBRWQ7UUFBUUU7UUFBU0U7UUFBT0U7UUFBYWdEO0lBQVU7QUFDMUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGVueW9uZ3hpYW5nL0RvY3VtZW50cy9HaXRIdWIvdHJhZmZpYy1tb25pdG9yL2Zyb250ZW5kL2hvb2tzL3VzZUNhbWVyYS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0V2ViU29ja2V0VXJsIH0gZnJvbSAnQC9zZXJ2aWNlcy9hcGknO1xuXG5pbnRlcmZhY2UgQ2FtZXJhU3RyZWFtIHtcbiAgaW1hZ2VVcmw6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuaW50ZXJmYWNlIFVzZUNhbWVyYVJlc3VsdCB7XG4gIHN0cmVhbTogQ2FtZXJhU3RyZWFtIHwgbnVsbDtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IEVycm9yIHwgbnVsbDtcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW47XG4gIHJlY29ubmVjdDogKCkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFdlYlNvY2tldEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIGVycm9yPzogRXJyb3I7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYW1lcmEoY2FtZXJhSWQ6IHN0cmluZyk6IFVzZUNhbWVyYVJlc3VsdCB7XG4gIGNvbnN0IFtzdHJlYW0sIHNldFN0cmVhbV0gPSB1c2VTdGF0ZTxDYW1lcmFTdHJlYW0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3IgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IHdzUmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCByZWNvbm5lY3RUaW1lb3V0UmVmID0gdXNlUmVmPFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCByZWNvbm5lY3RBdHRlbXB0c1JlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xuICBjb25zdCBNQVhfUkVDT05ORUNUX0FUVEVNUFRTID0gNTtcbiAgY29uc3QgUkVDT05ORUNUX0lOVEVSVkFMID0gMzAwMDtcblxuICBjb25zdCBjb25uZWN0VG9DYW1lcmEgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgLy8g6Zec6ZaJ54++5pyJ6YCj5o6lXG4gICAgICBpZiAod3NSZWYuY3VycmVudCkge1xuICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIOWJteW7uuaWsOeahFdlYlNvY2tldOmAo+aOpVxuICAgICAgY29uc3Qgd3NVcmwgPSBnZXRXZWJTb2NrZXRVcmwoY2FtZXJhSWQpO1xuICAgICAgY29uc29sZS5sb2coJ+ato+WcqOmAo+aOpeWIsFdlYlNvY2tldOacjeWLmeWZqDonLCB3c1VybCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldCh3c1VybCk7XG4gICAgICB3c1JlZi5jdXJyZW50ID0gd3M7XG5cbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dlYlNvY2tldOmAo+aOpeW3suW7uueriycpO1xuICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50ID0gMDtcbiAgICAgIH07XG5cbiAgICAgIHdzLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdmcmFtZScpIHtcbiAgICAgICAgICAgIHNldFN0cmVhbSh7XG4gICAgICAgICAgICAgIGltYWdlVXJsOiBgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwke2RhdGEuaW1hZ2V9YCxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShkYXRhLnRpbWVzdGFtcCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIGNhbWVyYU5hbWU6IGRhdGEuY2FtZXJhX25hbWUsXG4gICAgICAgICAgICAgICAgZnJhbWVOdW1iZXI6IGRhdGEuZnJhbWVfbnVtYmVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+aUtuWIsOmMr+iqpOa2iOaBrzonLCBkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgc2V0RXJyb3IobmV3IEVycm9yKGRhdGEubWVzc2FnZSkpO1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfop6PmnpDmlJ3lvbHmqZ/mlbjmk5rlpLHmlZc6JywgZXJyKTtcbiAgICAgICAgICBzZXRFcnJvcihuZXcgRXJyb3IoJ+ino+aekOaUneW9seapn+aVuOaTmuWkseaVlycpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd3Mub25lcnJvciA9IChldmVudDogV2ViU29ja2V0RXJyb3JFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvclRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVUZXh0ID0gd3MucmVhZHlTdGF0ZSA9PT0gMCA/ICfmraPlnKjpgKPmjqUnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MucmVhZHlTdGF0ZSA9PT0gMSA/ICflt7LpgKPmjqUnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MucmVhZHlTdGF0ZSA9PT0gMiA/ICfmraPlnKjpl5zploknIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MucmVhZHlTdGF0ZSA9PT0gMyA/ICflt7Lpl5zploknIDogJ+acquefpeeLgOaFiyc7XG5cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXZlbnQuZXJyb3IgaW5zdGFuY2VvZiBFcnJvciBcbiAgICAgICAgICA/IGAke2V2ZW50LmVycm9yLm5hbWV9OiAke2V2ZW50LmVycm9yLm1lc3NhZ2V9YFxuICAgICAgICAgIDogdHlwZW9mIGV2ZW50Lm1lc3NhZ2UgPT09ICdzdHJpbmcnIFxuICAgICAgICAgICAgPyBldmVudC5tZXNzYWdlIFxuICAgICAgICAgICAgOiAn5pyq55+l6Yyv6KqkJztcblxuICAgICAgICAvLyDnsKHljJbpjK/oqqTml6XoqoxcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2ViU29ja2V0IOmAo+aOpemMr+iqpCAtICR7ZXJyb3JUaW1lfSAtICR7ZXJyb3JNZXNzYWdlfSAtICR7d3NVcmx9IC0gJHtyZWFkeVN0YXRlVGV4dH1gKTtcblxuICAgICAgICAvLyDmm7TmlrDni4DmhYtcbiAgICAgICAgc2V0RXJyb3IobmV3IEVycm9yKGDmlJ3lvbHmqZ/pgKPmjqXpjK/oqqQ6ICR7ZXJyb3JNZXNzYWdlfWApKTtcbiAgICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH07XG5cbiAgICAgIHdzLm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dlYlNvY2tldOmAo+aOpeW3sumXnOmWiTonLCB7XG4gICAgICAgICAgY29kZTogZXZlbnQuY29kZSxcbiAgICAgICAgICByZWFzb246IGV2ZW50LnJlYXNvbiB8fCAn54Sh5Y6f5Zug5o+Q5L6bJyxcbiAgICAgICAgICB3YXNDbGVhbjogZXZlbnQud2FzQ2xlYW4sXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIOWYl+ippumHjemAo1xuICAgICAgICBpZiAocmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA8IE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMpIHtcbiAgICAgICAgICByZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDlmJfoqabph43mlrDpgKPmjqUgKCR7cmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCArIDF9LyR7TUFYX1JFQ09OTkVDVF9BVFRFTVBUU30pYCk7XG4gICAgICAgICAgICByZWNvbm5lY3RBdHRlbXB0c1JlZi5jdXJyZW50ICs9IDE7XG4gICAgICAgICAgICBjb25uZWN0VG9DYW1lcmEoKTtcbiAgICAgICAgICB9LCBSRUNPTk5FQ1RfSU5URVJWQUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEVycm9yKG5ldyBFcnJvcihg54Sh5rOV6YCj5o6l5Yiw5pSd5b2x5qmf77yM5bey5ZiX6KmmICR7TUFYX1JFQ09OTkVDVF9BVFRFTVBUU30g5qyhYCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfpgKPmjqXpjK/oqqQ6JywgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKCfpgKPmjqXmlJ3lvbHmqZ/mmYLnmbznlJ/pjK/oqqQnKSk7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtjYW1lcmFJZF0pO1xuXG4gIC8vIOaJi+WLlemHjemAo+WHveaVuFxuICBjb25zdCByZWNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmVjb25uZWN0QXR0ZW1wdHNSZWYuY3VycmVudCA9IDA7XG4gICAgY29ubmVjdFRvQ2FtZXJhKCk7XG4gIH0sIFtjb25uZWN0VG9DYW1lcmFdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbm5lY3RUb0NhbWVyYSgpO1xuXG4gICAgLy8g5riF55CG5Ye95pW4XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAod3NSZWYuY3VycmVudCkge1xuICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Nvbm5lY3RUb0NhbWVyYV0pO1xuXG4gIHJldHVybiB7IHN0cmVhbSwgbG9hZGluZywgZXJyb3IsIGlzQ29ubmVjdGVkLCByZWNvbm5lY3QgfTtcbn0gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJnZXRXZWJTb2NrZXRVcmwiLCJ1c2VDYW1lcmEiLCJjYW1lcmFJZCIsInN0cmVhbSIsInNldFN0cmVhbSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImlzQ29ubmVjdGVkIiwic2V0SXNDb25uZWN0ZWQiLCJ3c1JlZiIsInJlY29ubmVjdFRpbWVvdXRSZWYiLCJ1bmRlZmluZWQiLCJyZWNvbm5lY3RBdHRlbXB0c1JlZiIsIk1BWF9SRUNPTk5FQ1RfQVRURU1QVFMiLCJSRUNPTk5FQ1RfSU5URVJWQUwiLCJjb25uZWN0VG9DYW1lcmEiLCJjdXJyZW50IiwiY2xvc2UiLCJ3c1VybCIsImNvbnNvbGUiLCJsb2ciLCJ3cyIsIldlYlNvY2tldCIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsImV2ZW50IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsInR5cGUiLCJpbWFnZVVybCIsImltYWdlIiwidGltZXN0YW1wIiwiRGF0ZSIsImdldFRpbWUiLCJtZXRhZGF0YSIsImNhbWVyYU5hbWUiLCJjYW1lcmFfbmFtZSIsImZyYW1lTnVtYmVyIiwiZnJhbWVfbnVtYmVyIiwibWVzc2FnZSIsIkVycm9yIiwiZXJyIiwib25lcnJvciIsImVycm9yVGltZSIsInRvSVNPU3RyaW5nIiwicmVhZHlTdGF0ZVRleHQiLCJyZWFkeVN0YXRlIiwiZXJyb3JNZXNzYWdlIiwibmFtZSIsIm9uY2xvc2UiLCJjb2RlIiwicmVhc29uIiwid2FzQ2xlYW4iLCJzZXRUaW1lb3V0IiwicmVjb25uZWN0IiwiY2xlYXJUaW1lb3V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCamera.ts\n"));

/***/ })

});